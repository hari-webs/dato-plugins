"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitNormalizedFieldValuesAsync = exports.visitNormalizedFieldValues = exports.everyNormalizedFieldValueAsync = exports.everyNormalizedFieldValue = exports.someNormalizedFieldValuesAsync = exports.someNormalizedFieldValues = exports.filterNormalizedFieldValuesAsync = exports.filterNormalizedFieldValues = exports.mapNormalizedFieldValuesAsync = exports.mapNormalizedFieldValues = exports.fromNormalizedFieldValueEntries = exports.toNormalizedFieldValueEntries = exports.isLocalizedFieldValue = exports.isLocalized = void 0;
/**
 * Determines whether a DatoCMS field is localized or not.
 *
 * This function handles both full Schema field objects and simplified Schema field objects
 * by checking the appropriate property based on the object structure.
 *
 * @returns true if the field is localized, false otherwise
 * @param field - The DatoCMS field definition (either full or simple schema)
 */
function isLocalized(field) {
    return 'attributes' in field ? field.attributes.localized : field.localized;
}
exports.isLocalized = isLocalized;
function isLocalizedFieldValue(value) {
    if (typeof value !== 'object' || value === null || Array.isArray(value)) {
        return false;
    }
    const keys = Object.keys(value);
    if (keys.length === 0) {
        return false;
    }
    const localePattern = /^[A-Za-z]{2,4}(-[A-Za-z]{4})?(-([A-Za-z]{2}|[0-9]{3}))?$/;
    return keys.every((key) => localePattern.test(key));
}
exports.isLocalizedFieldValue = isLocalizedFieldValue;
/**
 * Converts a field value (localized or non-localized) into a uniform array of entries.
 *
 * This function normalizes the handling of field values by converting them into a consistent
 * array format, regardless of whether the field is localized or not.
 *
 * @param value - The field value to convert (either a localized object or direct value)
 * @param field - The DatoCMS field definition that determines localization behavior
 * @returns Array of entries where each entry contains a locale (string for localized, undefined for non-localized) and the corresponding value
 */
function toNormalizedFieldValueEntries(value, field) {
    if (isLocalized(field)) {
        const localizedValue = value;
        return Object.entries(localizedValue).map(([locale, value]) => ({
            locale: locale,
            value: value,
        }));
    }
    return [{ locale: undefined, value: value }];
}
exports.toNormalizedFieldValueEntries = toNormalizedFieldValueEntries;
/**
 * Converts an array of possibly localized entries back into the appropriate field value format.
 *
 * This function is the inverse of `toNormalizedFieldValueEntries`. It takes a uniform
 * array of entries and converts them back to either a localized object or a direct value,
 * depending on the field's localization setting.
 *
 * @param entries - Array of entries to convert back to field value format
 * @param field - The DatoCMS field definition that determines the output format
 * @returns Either a localized object (for localized fields) or the direct value (for non-localized fields)
 */
function fromNormalizedFieldValueEntries(entries, field) {
    if (isLocalized(field)) {
        return Object.fromEntries(entries.map(({ locale, value }) => [locale, value]));
    }
    if (entries.length === 0) {
        throw new Error('There must be at least one entry!');
    }
    return entries[0].value;
}
exports.fromNormalizedFieldValueEntries = fromNormalizedFieldValueEntries;
/**
 * Maps field values using a provided mapping function.
 * For localized fields, applies the mapping function to each locale value.
 * For non-localized fields, applies the mapping function directly to the value.
 *
 * @template T - The type that the mapping function returns
 * @param localizedOrNonLocalizedFieldValue - The field value (either localized object or direct value)
 * @param field - The DatoCMS field definition
 * @param mapFn - The function to apply to each locale value or the direct value
 * @returns The mapped value with the same structure as the input
 */
function mapNormalizedFieldValues(localizedOrNonLocalizedFieldValue, field, mapFn) {
    const entries = toNormalizedFieldValueEntries(localizedOrNonLocalizedFieldValue, field);
    const mappedEntries = entries.map(({ locale, value }) => ({
        locale,
        value: mapFn(locale, value),
    }));
    return fromNormalizedFieldValueEntries(mappedEntries, field);
}
exports.mapNormalizedFieldValues = mapNormalizedFieldValues;
/**
 * Maps field values using a provided mapping function (async version).
 * For localized fields, applies the mapping function to each locale value.
 * For non-localized fields, applies the mapping function directly to the value.
 *
 * @template T - The type that the mapping function returns
 * @param localizedOrNonLocalizedFieldValue - The field value (either localized object or direct value)
 * @param field - The DatoCMS field definition
 * @param mapFn - The function to apply to each locale value or the direct value
 * @returns The mapped value with the same structure as the input
 */
function mapNormalizedFieldValuesAsync(localizedOrNonLocalizedFieldValue, field, mapFn) {
    return __awaiter(this, void 0, void 0, function* () {
        const entries = toNormalizedFieldValueEntries(localizedOrNonLocalizedFieldValue, field);
        const mappedEntries = yield Promise.all(entries.map(({ locale, value }) => __awaiter(this, void 0, void 0, function* () {
            return ({
                locale,
                value: yield mapFn(locale, value),
            });
        })));
        return fromNormalizedFieldValueEntries(mappedEntries, field);
    });
}
exports.mapNormalizedFieldValuesAsync = mapNormalizedFieldValuesAsync;
/**
 * Filters field values using a provided filter function.
 * For localized fields, filters each locale value.
 * For non-localized fields, returns the value if the filter passes, otherwise undefined.
 *
 * @param localizedOrNonLocalizedFieldValue - The field value (either localized object or direct value)
 * @param field - The DatoCMS field definition
 * @param filterFn - The function to test each locale value or the direct value
 * @returns The filtered value with the same structure as the input
 */
function filterNormalizedFieldValues(localizedOrNonLocalizedFieldValue, field, filterFn) {
    var _a;
    const entries = toNormalizedFieldValueEntries(localizedOrNonLocalizedFieldValue, field);
    const filteredEntries = entries.filter((entry) => filterFn(entry.locale, entry.value));
    if (isLocalized(field)) {
        return fromNormalizedFieldValueEntries(filteredEntries, field);
    }
    return filteredEntries.length > 0 ? (_a = filteredEntries[0]) === null || _a === void 0 ? void 0 : _a.value : undefined;
}
exports.filterNormalizedFieldValues = filterNormalizedFieldValues;
/**
 * Filters field values using a provided filter function (async version).
 * For localized fields, filters each locale value.
 * For non-localized fields, returns the value if the filter passes, otherwise undefined.
 *
 * @param localizedOrNonLocalizedFieldValue - The field value (either localized object or direct value)
 * @param field - The DatoCMS field definition
 * @param filterFn - The function to test each locale value or the direct value
 * @returns The filtered value with the same structure as the input
 */
function filterNormalizedFieldValuesAsync(localizedOrNonLocalizedFieldValue, field, filterFn) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const entries = toNormalizedFieldValueEntries(localizedOrNonLocalizedFieldValue, field);
        const results = yield Promise.all(entries.map(({ locale, value }) => __awaiter(this, void 0, void 0, function* () {
            return ({
                locale,
                value,
                passed: yield filterFn(locale, value),
            });
        })));
        const filteredEntries = results
            .filter(({ passed }) => passed)
            .map(({ locale, value }) => ({ locale, value }));
        if (isLocalized(field)) {
            return fromNormalizedFieldValueEntries(filteredEntries, field);
        }
        return filteredEntries.length > 0 ? (_a = filteredEntries[0]) === null || _a === void 0 ? void 0 : _a.value : undefined;
    });
}
exports.filterNormalizedFieldValuesAsync = filterNormalizedFieldValuesAsync;
/**
 * Tests whether at least one field value passes the test implemented by the provided function.
 * For localized fields, tests each locale value.
 * For non-localized fields, tests the direct value.
 *
 * @param localizedOrNonLocalizedFieldValue - The field value (either localized object or direct value)
 * @param field - The DatoCMS field definition
 * @param testFn - The function to test each locale value or the direct value
 * @returns true if at least one value passes the test, false otherwise
 */
function someNormalizedFieldValues(localizedOrNonLocalizedFieldValue, field, testFn) {
    const entries = toNormalizedFieldValueEntries(localizedOrNonLocalizedFieldValue, field);
    return entries.some(({ locale, value }) => testFn(locale, value));
}
exports.someNormalizedFieldValues = someNormalizedFieldValues;
/**
 * Tests whether at least one field value passes the test implemented by the provided function (async version).
 * For localized fields, tests each locale value.
 * For non-localized fields, tests the direct value.
 *
 * @param localizedOrNonLocalizedFieldValue - The field value (either localized object or direct value)
 * @param field - The DatoCMS field definition
 * @param testFn - The function to test each locale value or the direct value
 * @returns true if at least one value passes the test, false otherwise
 */
function someNormalizedFieldValuesAsync(localizedOrNonLocalizedFieldValue, field, testFn) {
    return __awaiter(this, void 0, void 0, function* () {
        const entries = toNormalizedFieldValueEntries(localizedOrNonLocalizedFieldValue, field);
        const results = yield Promise.all(entries.map(({ locale, value }) => testFn(locale, value)));
        return results.some((result) => result);
    });
}
exports.someNormalizedFieldValuesAsync = someNormalizedFieldValuesAsync;
/**
 * Tests whether all field values pass the test implemented by the provided function.
 * For localized fields, tests each locale value.
 * For non-localized fields, tests the direct value.
 *
 * @param localizedOrNonLocalizedFieldValue - The field value (either localized object or direct value)
 * @param field - The DatoCMS field definition
 * @param testFn - The function to test each locale value or the direct value
 * @returns true if all values pass the test, false otherwise
 */
function everyNormalizedFieldValue(localizedOrNonLocalizedFieldValue, field, testFn) {
    return !someNormalizedFieldValues(localizedOrNonLocalizedFieldValue, field, (locale, localeValue) => !testFn(locale, localeValue));
}
exports.everyNormalizedFieldValue = everyNormalizedFieldValue;
/**
 * Tests whether all field values pass the test implemented by the provided function (async version).
 * For localized fields, tests each locale value.
 * For non-localized fields, tests the direct value.
 *
 * @param localizedOrNonLocalizedFieldValue - The field value (either localized object or direct value)
 * @param field - The DatoCMS field definition
 * @param testFn - The function to test each locale value or the direct value
 * @returns true if all values pass the test, false otherwise
 */
function everyNormalizedFieldValueAsync(localizedOrNonLocalizedFieldValue, field, testFn) {
    return __awaiter(this, void 0, void 0, function* () {
        return !(yield someNormalizedFieldValuesAsync(localizedOrNonLocalizedFieldValue, field, (locale, localeValue) => __awaiter(this, void 0, void 0, function* () { return !(yield testFn(locale, localeValue)); })));
    });
}
exports.everyNormalizedFieldValueAsync = everyNormalizedFieldValueAsync;
/**
 * Visits each field value with the provided function.
 * For localized fields, visits each locale value.
 * For non-localized fields, visits the direct value.
 *
 * @param value - The field value (either localized object or direct value)
 * @param field - The DatoCMS field definition
 * @param visitFn - The function to call for each locale value or the direct value
 */
function visitNormalizedFieldValues(value, field, visitFn) {
    const entries = toNormalizedFieldValueEntries(value, field);
    for (const { locale, value } of entries) {
        visitFn(locale, value);
    }
}
exports.visitNormalizedFieldValues = visitNormalizedFieldValues;
/**
 * Visits each field value with the provided function (async version).
 * For localized fields, visits each locale value.
 * For non-localized fields, visits the direct value.
 *
 * @param localizedOrNonLocalizedFieldValue - The field value (either localized object or direct value)
 * @param field - The DatoCMS field definition
 * @param visitFn - The function to call for each locale value or the direct value
 */
function visitNormalizedFieldValuesAsync(localizedOrNonLocalizedFieldValue, field, visitFn) {
    return __awaiter(this, void 0, void 0, function* () {
        const entries = toNormalizedFieldValueEntries(localizedOrNonLocalizedFieldValue, field);
        yield Promise.all(entries.map(({ locale, value }) => visitFn(locale, value)));
    });
}
exports.visitNormalizedFieldValuesAsync = visitNormalizedFieldValuesAsync;
//# sourceMappingURL=normalizedFieldValues.js.map