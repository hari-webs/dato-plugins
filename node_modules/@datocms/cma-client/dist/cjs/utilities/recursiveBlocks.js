"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapBlocksInNonLocalizedFieldValue = exports.everyBlockInNonLocalizedFieldValue = exports.someBlocksInNonLocalizedFieldValue = exports.reduceBlocksInNonLocalizedFieldValue = exports.filterBlocksInNonLocalizedFieldValue = exports.findAllBlocksInNonLocalizedFieldValue = exports.visitBlocksInNonLocalizedFieldValue = void 0;
const fieldTypes_1 = require("../fieldTypes");
const nonRecursiveBlocks_1 = require("./nonRecursiveBlocks");
function visitBlocksInNonLocalizedFieldValue(nonLocalizedFieldValue, fieldType, schemaRepository, visitor, path = []) {
    return __awaiter(this, void 0, void 0, function* () {
        yield (0, nonRecursiveBlocks_1.nonRecursiveVisitBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, (block, innerPath) => __awaiter(this, void 0, void 0, function* () {
            yield visitor(block, [...path, ...innerPath]);
            if (!(0, fieldTypes_1.isItemWithOptionalIdAndMeta)(block)) {
                return;
            }
            const itemType = yield schemaRepository.getRawItemTypeById(block.relationships.item_type.data.id);
            const fields = yield schemaRepository.getRawItemTypeFields(itemType);
            for (const field of fields) {
                yield visitBlocksInNonLocalizedFieldValue(block.attributes[field.attributes.api_key], field.attributes.field_type, schemaRepository, visitor, [...path, ...innerPath, 'attributes', field.attributes.api_key]);
            }
        }));
    });
}
exports.visitBlocksInNonLocalizedFieldValue = visitBlocksInNonLocalizedFieldValue;
function findAllBlocksInNonLocalizedFieldValue(nonLocalizedFieldValue, fieldType, schemaRepository, predicate, path = []) {
    return __awaiter(this, void 0, void 0, function* () {
        const results = [];
        const directMatches = yield (0, nonRecursiveBlocks_1.nonRecursiveFindAllBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, (block, innerPath) => __awaiter(this, void 0, void 0, function* () { return yield predicate(block, [...path, ...innerPath]); }));
        results.push(...directMatches.map(({ item, path: innerPath }) => ({
            item,
            path: [...path, ...innerPath],
        })));
        yield (0, nonRecursiveBlocks_1.nonRecursiveVisitBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, (block, innerPath) => __awaiter(this, void 0, void 0, function* () {
            if (!(0, fieldTypes_1.isItemWithOptionalIdAndMeta)(block)) {
                return;
            }
            const itemType = yield schemaRepository.getRawItemTypeById(block.relationships.item_type.data.id);
            const fields = yield schemaRepository.getRawItemTypeFields(itemType);
            for (const field of fields) {
                const nestedResults = yield findAllBlocksInNonLocalizedFieldValue(block.attributes[field.attributes.api_key], field.attributes.field_type, schemaRepository, predicate, [...path, ...innerPath, 'attributes', field.attributes.api_key]);
                results.push(...nestedResults);
            }
        }));
        return results;
    });
}
exports.findAllBlocksInNonLocalizedFieldValue = findAllBlocksInNonLocalizedFieldValue;
function filterBlocksInNonLocalizedFieldValue(nonLocalizedFieldValue, fieldType, schemaRepository, predicate, options = {}, path = []) {
    return __awaiter(this, void 0, void 0, function* () {
        const { traversalDirection = 'top-down' } = options;
        const mapperFunc = (block, innerPath) => __awaiter(this, void 0, void 0, function* () {
            const blockPath = [...path, ...innerPath];
            if (!(0, fieldTypes_1.isItemWithOptionalIdAndMeta)(block)) {
                return block;
            }
            const itemType = yield schemaRepository.getRawItemTypeById(block.relationships.item_type.data.id);
            const fields = yield schemaRepository.getRawItemTypeFields(itemType);
            if (traversalDirection === 'top-down') {
                const blockCopy = Object.assign(Object.assign({}, block), { attributes: Object.assign({}, block.attributes) });
                for (const field of fields) {
                    blockCopy.attributes[field.attributes.api_key] =
                        yield filterBlocksInNonLocalizedFieldValue(blockCopy.attributes[field.attributes.api_key], field.attributes.field_type, schemaRepository, predicate, options, [...blockPath, 'attributes', field.attributes.api_key]);
                }
                return blockCopy;
            }
            const blockCopy = Object.assign(Object.assign({}, block), { attributes: Object.assign({}, block.attributes) });
            for (const field of fields) {
                blockCopy.attributes[field.attributes.api_key] =
                    yield filterBlocksInNonLocalizedFieldValue(blockCopy.attributes[field.attributes.api_key], field.attributes.field_type, schemaRepository, predicate, options, [...blockPath, 'attributes', field.attributes.api_key]);
            }
            return blockCopy;
        });
        const mappedValue = yield (0, nonRecursiveBlocks_1.nonRecursiveMapBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, mapperFunc);
        return (0, nonRecursiveBlocks_1.nonRecursiveFilterBlocksInNonLocalizedFieldValueAsync)(fieldType, mappedValue, (block, innerPath) => __awaiter(this, void 0, void 0, function* () {
            const blockPath = [...path, ...innerPath];
            return yield predicate(block, blockPath);
        }));
    });
}
exports.filterBlocksInNonLocalizedFieldValue = filterBlocksInNonLocalizedFieldValue;
function reduceBlocksInNonLocalizedFieldValue(nonLocalizedFieldValue, fieldType, schemaRepository, reducer, initialValue, path = []) {
    return __awaiter(this, void 0, void 0, function* () {
        let accumulator = yield (0, nonRecursiveBlocks_1.nonRecursiveReduceBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, (acc, block, innerPath) => __awaiter(this, void 0, void 0, function* () { return yield reducer(acc, block, [...path, ...innerPath]); }), initialValue);
        yield (0, nonRecursiveBlocks_1.nonRecursiveVisitBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, (block, innerPath) => __awaiter(this, void 0, void 0, function* () {
            if (!(0, fieldTypes_1.isItemWithOptionalIdAndMeta)(block)) {
                return;
            }
            const itemType = yield schemaRepository.getRawItemTypeById(block.relationships.item_type.data.id);
            const fields = yield schemaRepository.getRawItemTypeFields(itemType);
            for (const field of fields) {
                accumulator = yield reduceBlocksInNonLocalizedFieldValue(block.attributes[field.attributes.api_key], field.attributes.field_type, schemaRepository, reducer, accumulator, [...path, ...innerPath, 'attributes', field.attributes.api_key]);
            }
        }));
        return accumulator;
    });
}
exports.reduceBlocksInNonLocalizedFieldValue = reduceBlocksInNonLocalizedFieldValue;
function someBlocksInNonLocalizedFieldValue(nonLocalizedFieldValue, fieldType, schemaRepository, predicate, path = []) {
    return __awaiter(this, void 0, void 0, function* () {
        const directMatch = yield (0, nonRecursiveBlocks_1.nonRecursiveSomeBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, (block, innerPath) => __awaiter(this, void 0, void 0, function* () { return yield predicate(block, [...path, ...innerPath]); }));
        if (directMatch) {
            return true;
        }
        let found = false;
        yield (0, nonRecursiveBlocks_1.nonRecursiveVisitBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, (block, innerPath) => __awaiter(this, void 0, void 0, function* () {
            if (found || !(0, fieldTypes_1.isItemWithOptionalIdAndMeta)(block)) {
                return;
            }
            const itemType = yield schemaRepository.getRawItemTypeById(block.relationships.item_type.data.id);
            const fields = yield schemaRepository.getRawItemTypeFields(itemType);
            for (const field of fields) {
                if (found)
                    break;
                const nestedMatch = yield someBlocksInNonLocalizedFieldValue(block.attributes[field.attributes.api_key], field.attributes.field_type, schemaRepository, predicate, [...path, ...innerPath, 'attributes', field.attributes.api_key]);
                if (nestedMatch) {
                    found = true;
                }
            }
        }));
        return found;
    });
}
exports.someBlocksInNonLocalizedFieldValue = someBlocksInNonLocalizedFieldValue;
function everyBlockInNonLocalizedFieldValue(nonLocalizedFieldValue, fieldType, schemaRepository, predicate, path = []) {
    return __awaiter(this, void 0, void 0, function* () {
        return !(yield someBlocksInNonLocalizedFieldValue(nonLocalizedFieldValue, fieldType, schemaRepository, (item, path) => __awaiter(this, void 0, void 0, function* () { return !(yield predicate(item, path)); }), path));
    });
}
exports.everyBlockInNonLocalizedFieldValue = everyBlockInNonLocalizedFieldValue;
function mapBlocksInNonLocalizedFieldValue(nonLocalizedFieldValue, fieldType, schemaRepository, mapper, options = {}, path = []) {
    return __awaiter(this, void 0, void 0, function* () {
        const { traversalDirection = 'top-down' } = options;
        return (0, nonRecursiveBlocks_1.nonRecursiveMapBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, (block, innerPath) => __awaiter(this, void 0, void 0, function* () {
            const blockPath = [...path, ...innerPath];
            if (!(0, fieldTypes_1.isItemWithOptionalIdAndMeta)(block)) {
                return yield mapper(block, blockPath);
            }
            const itemType = yield schemaRepository.getRawItemTypeById(block.relationships.item_type.data.id);
            const fields = yield schemaRepository.getRawItemTypeFields(itemType);
            if (traversalDirection === 'top-down') {
                const newBlock = yield mapper(block, blockPath);
                if (!(0, fieldTypes_1.isItemWithOptionalIdAndMeta)(newBlock)) {
                    return newBlock;
                }
                for (const field of fields) {
                    newBlock.attributes[field.attributes.api_key] =
                        yield mapBlocksInNonLocalizedFieldValue(newBlock.attributes[field.attributes.api_key], field.attributes.field_type, schemaRepository, mapper, options, [...blockPath, 'attributes', field.attributes.api_key]);
                }
                return newBlock;
            }
            const blockCopy = Object.assign({}, block);
            for (const field of fields) {
                blockCopy.attributes[field.attributes.api_key] =
                    yield mapBlocksInNonLocalizedFieldValue(blockCopy.attributes[field.attributes.api_key], field.attributes.field_type, schemaRepository, mapper, options, [...blockPath, 'attributes', field.attributes.api_key]);
            }
            return yield mapper(blockCopy, blockPath);
        }));
    });
}
exports.mapBlocksInNonLocalizedFieldValue = mapBlocksInNonLocalizedFieldValue;
//# sourceMappingURL=recursiveBlocks.js.map