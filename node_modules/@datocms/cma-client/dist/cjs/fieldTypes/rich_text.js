"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isLocalizedRichTextFieldValueInNestedResponse = exports.isRichTextFieldValueInNestedResponse = exports.isLocalizedRichTextFieldValueInRequest = exports.isRichTextFieldValueInRequest = exports.isLocalizedRichTextFieldValue = exports.isRichTextFieldValue = void 0;
const id_1 = require("../utilities/id");
const normalizedFieldValues_1 = require("../utilities/normalizedFieldValues");
const single_block_1 = require("./single_block");
/**
 * =============================================================================
 * TYPE GUARDS - Runtime validation functions
 * =============================================================================
 */
/**
 * Type guard for basic Modular Content field values (blocks as string IDs only).
 * Checks for array structure and ensures all blocks are string references.
 */
function isRichTextFieldValue(value) {
    return (Array.isArray(value) &&
        value.every((block) => typeof block === 'string' && (0, id_1.isValidId)(block)));
}
exports.isRichTextFieldValue = isRichTextFieldValue;
function isLocalizedRichTextFieldValue(value) {
    return ((0, normalizedFieldValues_1.isLocalizedFieldValue)(value) &&
        Object.values(value).every(isRichTextFieldValue));
}
exports.isLocalizedRichTextFieldValue = isLocalizedRichTextFieldValue;
/**
 * Type guard for Modular Content field values in API request format.
 * Allows blocks as string IDs, full objects with IDs, or objects without IDs.
 */
function isRichTextFieldValueInRequest(value) {
    if (value === null)
        return true;
    if (!Array.isArray(value))
        return false;
    return value.every((block) => {
        // String ID - referencing existing block
        if ((0, single_block_1.isItemId)(block))
            return true;
        // Object (either with or without ID for updates/creation)
        return (0, single_block_1.isItemWithOptionalIdAndMeta)(block);
    });
}
exports.isRichTextFieldValueInRequest = isRichTextFieldValueInRequest;
function isLocalizedRichTextFieldValueInRequest(value) {
    return ((0, normalizedFieldValues_1.isLocalizedFieldValue)(value) &&
        Object.values(value).every(isRichTextFieldValueInRequest));
}
exports.isLocalizedRichTextFieldValueInRequest = isLocalizedRichTextFieldValueInRequest;
/**
 * Type guard for Modular Content field values with nested blocks (?nested=true format).
 * Ensures all blocks are full RawApiTypes.Item objects with complete data.
 */
function isRichTextFieldValueInNestedResponse(value) {
    if (!Array.isArray(value))
        return false;
    return value.every((block) => {
        // Must be a full object with ID (nested format always includes complete block objects)
        return (0, single_block_1.isItemWithOptionalMeta)(block);
    });
}
exports.isRichTextFieldValueInNestedResponse = isRichTextFieldValueInNestedResponse;
function isLocalizedRichTextFieldValueInNestedResponse(value) {
    return ((0, normalizedFieldValues_1.isLocalizedFieldValue)(value) &&
        Object.values(value).every(isRichTextFieldValueInNestedResponse));
}
exports.isLocalizedRichTextFieldValueInNestedResponse = isLocalizedRichTextFieldValueInNestedResponse;
//# sourceMappingURL=rich_text.js.map